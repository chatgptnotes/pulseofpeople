"""
Django Management Command: import_electoral_data
================================================
Imports electoral data from CSV files generated by electoral_data_converter.py

Usage:
    python manage.py import_electoral_data <data_directory>
    python manage.py import_electoral_data ./output --clear
    python manage.py import_electoral_data ./output --dry-run
"""

import csv
import json
import os
from decimal import Decimal
from pathlib import Path
from typing import Dict, List, Optional

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from django.utils import timezone

from api.models import State, District, Constituency, PollingBooth


class Command(BaseCommand):
    help = 'Import electoral data from CSV files'

    def add_arguments(self, parser):
        parser.add_argument(
            'data_dir',
            type=str,
            help='Directory containing CSV files (states.csv, districts.csv, etc.)'
        )
        parser.add_argument(
            '--clear',
            action='store_true',
            help='Clear existing data before import (DANGEROUS!)'
        )
        parser.add_argument(
            '--dry-run',
            action='store_true',
            help='Simulate import without saving to database'
        )
        parser.add_argument(
            '--skip-existing',
            action='store_true',
            help='Skip records that already exist (based on code/unique fields)'
        )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.stats = {
            'states': {'created': 0, 'updated': 0, 'skipped': 0, 'errors': 0},
            'districts': {'created': 0, 'updated': 0, 'skipped': 0, 'errors': 0},
            'constituencies': {'created': 0, 'updated': 0, 'skipped': 0, 'errors': 0},
            'booths': {'created': 0, 'updated': 0, 'skipped': 0, 'errors': 0},
        }
        self.state_cache: Dict[str, State] = {}
        self.district_cache: Dict[str, District] = {}
        self.constituency_cache: Dict[str, Constituency] = {}

    def handle(self, *args, **options):
        data_dir = Path(options['data_dir'])

        if not data_dir.exists():
            raise CommandError(f"Directory not found: {data_dir}")

        self.stdout.write("="*70)
        self.stdout.write(self.style.SUCCESS("üì• ELECTORAL DATA IMPORT"))
        self.stdout.write("="*70)
        self.stdout.write(f"Data directory: {data_dir}")
        self.stdout.write(f"Dry run: {options['dry_run']}")
        self.stdout.write(f"Clear existing: {options['clear']}")
        self.stdout.write(f"Skip existing: {options['skip_existing']}")
        self.stdout.write("="*70 + "\n")

        # Check for required files
        required_files = ['states.csv', 'districts.csv', 'constituencies.csv', 'polling_booths.csv']
        missing_files = [f for f in required_files if not (data_dir / f).exists()]

        if missing_files:
            self.stdout.write(self.style.WARNING(f"‚ö†Ô∏è  Missing files: {', '.join(missing_files)}"))
            self.stdout.write("Available files will be imported.\n")

        try:
            with transaction.atomic():
                # Clear existing data if requested
                if options['clear'] and not options['dry_run']:
                    self._clear_data()

                # Import in order (respecting foreign key dependencies)
                if (data_dir / 'states.csv').exists():
                    self._import_states(data_dir / 'states.csv', options)

                if (data_dir / 'districts.csv').exists():
                    self._import_districts(data_dir / 'districts.csv', options)

                if (data_dir / 'constituencies.csv').exists():
                    self._import_constituencies(data_dir / 'constituencies.csv', options)

                if (data_dir / 'polling_booths.csv').exists():
                    self._import_polling_booths(data_dir / 'polling_booths.csv', options)

                if options['dry_run']:
                    self.stdout.write(self.style.WARNING("\nüîÑ DRY RUN - Rolling back transaction"))
                    raise Exception("Dry run - rolling back")

        except Exception as e:
            if options['dry_run']:
                pass  # Expected for dry run
            else:
                self.stdout.write(self.style.ERROR(f"\n‚ùå Import failed: {e}"))
                raise

        # Print summary
        self._print_summary(options['dry_run'])

        if not options['dry_run']:
            self.stdout.write(self.style.SUCCESS("\n‚úÖ IMPORT COMPLETE!"))

    def _clear_data(self):
        """Clear existing electoral data"""
        self.stdout.write(self.style.WARNING("üóëÔ∏è  Clearing existing data..."))

        counts = {
            'booths': PollingBooth.objects.count(),
            'constituencies': Constituency.objects.count(),
            'districts': District.objects.count(),
            'states': State.objects.count(),
        }

        PollingBooth.objects.all().delete()
        Constituency.objects.all().delete()
        District.objects.all().delete()
        State.objects.all().delete()

        self.stdout.write(f"   Deleted: {counts['states']} states, {counts['districts']} districts, "
                         f"{counts['constituencies']} constituencies, {counts['booths']} booths")

    def _import_states(self, file_path: Path, options: dict):
        """Import states from CSV"""
        self.stdout.write(f"\nüìç Importing states from {file_path.name}...")

        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    code = row['code'].strip()

                    if options['skip_existing'] and State.objects.filter(code=code).exists():
                        self.stats['states']['skipped'] += 1
                        continue

                    if not options['dry_run']:
                        state, created = State.objects.update_or_create(
                            code=code,
                            defaults={
                                'name': row['name'].strip(),
                                'capital': row.get('capital', '').strip(),
                                'region': row.get('region', '').strip(),
                                'total_districts': int(row.get('total_districts', 0) or 0),
                                'total_constituencies': int(row.get('total_constituencies', 0) or 0),
                            }
                        )
                        self.state_cache[code] = state

                        if created:
                            self.stats['states']['created'] += 1
                        else:
                            self.stats['states']['updated'] += 1
                    else:
                        self.stats['states']['created'] += 1

                except Exception as e:
                    self.stats['states']['errors'] += 1
                    self.stdout.write(self.style.ERROR(f"   Error importing state {row.get('code')}: {e}"))

        self.stdout.write(f"   ‚úÖ Processed {sum(self.stats['states'].values())} states")

    def _import_districts(self, file_path: Path, options: dict):
        """Import districts from CSV"""
        self.stdout.write(f"\nüèôÔ∏è  Importing districts from {file_path.name}...")

        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    code = row['code'].strip()
                    state_code = row['state_code'].strip()

                    if options['skip_existing'] and District.objects.filter(code=code).exists():
                        self.stats['districts']['skipped'] += 1
                        continue

                    # Get or fetch state
                    if state_code not in self.state_cache:
                        try:
                            self.state_cache[state_code] = State.objects.get(code=state_code)
                        except State.DoesNotExist:
                            self.stdout.write(self.style.ERROR(f"   State {state_code} not found for district {code}"))
                            self.stats['districts']['errors'] += 1
                            continue

                    state = self.state_cache[state_code]

                    if not options['dry_run']:
                        district, created = District.objects.update_or_create(
                            code=code,
                            defaults={
                                'state': state,
                                'name': row['name'].strip(),
                                'headquarters': row.get('headquarters', '').strip(),
                                'population': int(row.get('population', 0) or 0) if row.get('population') else None,
                                'area_sq_km': Decimal(row.get('area_sq_km', 0) or 0) if row.get('area_sq_km') else None,
                                'total_wards': int(row.get('total_wards', 0) or 0),
                            }
                        )
                        self.district_cache[code] = district

                        if created:
                            self.stats['districts']['created'] += 1
                        else:
                            self.stats['districts']['updated'] += 1
                    else:
                        self.stats['districts']['created'] += 1

                except Exception as e:
                    self.stats['districts']['errors'] += 1
                    self.stdout.write(self.style.ERROR(f"   Error importing district {row.get('code')}: {e}"))

        self.stdout.write(f"   ‚úÖ Processed {sum(self.stats['districts'].values())} districts")

    def _import_constituencies(self, file_path: Path, options: dict):
        """Import constituencies from CSV"""
        self.stdout.write(f"\nüó≥Ô∏è  Importing constituencies from {file_path.name}...")

        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    code = row['code'].strip()
                    state_code = row['state_code'].strip()
                    district_code = row.get('district_code', '').strip()

                    if options['skip_existing'] and Constituency.objects.filter(code=code).exists():
                        self.stats['constituencies']['skipped'] += 1
                        continue

                    # Get state
                    if state_code not in self.state_cache:
                        try:
                            self.state_cache[state_code] = State.objects.get(code=state_code)
                        except State.DoesNotExist:
                            self.stdout.write(self.style.ERROR(f"   State {state_code} not found"))
                            self.stats['constituencies']['errors'] += 1
                            continue

                    state = self.state_cache[state_code]

                    # Get district (optional)
                    district = None
                    if district_code:
                        if district_code not in self.district_cache:
                            try:
                                self.district_cache[district_code] = District.objects.get(code=district_code)
                            except District.DoesNotExist:
                                self.stdout.write(self.style.WARNING(f"   District {district_code} not found (optional)"))

                        district = self.district_cache.get(district_code)

                    if not options['dry_run']:
                        constituency, created = Constituency.objects.update_or_create(
                            code=code,
                            defaults={
                                'state': state,
                                'district': district,
                                'name': row['name'].strip(),
                                'constituency_type': row.get('constituency_type', 'assembly'),
                                'number': int(row.get('number', 0) or 0),
                                'reserved_for': row.get('reserved_for', 'general'),
                                'total_voters': int(row.get('total_voters', 0) or 0) if row.get('total_voters') else None,
                                'total_wards': int(row.get('total_wards', 0) or 0),
                                'total_booths': int(row.get('total_booths', 0) or 0),
                                'area_sq_km': Decimal(row.get('area_sq_km', 0) or 0) if row.get('area_sq_km') else None,
                                'metadata': json.loads(row.get('metadata', '{}')) if row.get('metadata') else {},
                            }
                        )
                        self.constituency_cache[code] = constituency

                        if created:
                            self.stats['constituencies']['created'] += 1
                        else:
                            self.stats['constituencies']['updated'] += 1
                    else:
                        self.stats['constituencies']['created'] += 1

                except Exception as e:
                    self.stats['constituencies']['errors'] += 1
                    self.stdout.write(self.style.ERROR(f"   Error importing constituency {row.get('code')}: {e}"))

        self.stdout.write(f"   ‚úÖ Processed {sum(self.stats['constituencies'].values())} constituencies")

    def _import_polling_booths(self, file_path: Path, options: dict):
        """Import polling booths from CSV"""
        self.stdout.write(f"\nüó≥Ô∏è  Importing polling booths from {file_path.name}...")

        with open(file_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            batch = []
            batch_size = 500

            for row in reader:
                try:
                    state_code = row['state_code'].strip()
                    district_code = row['district_code'].strip()
                    constituency_code = row['constituency_code'].strip()
                    booth_number = row['booth_number'].strip()

                    # Get foreign keys
                    if state_code not in self.state_cache:
                        self.state_cache[state_code] = State.objects.get(code=state_code)
                    if district_code not in self.district_cache:
                        self.district_cache[district_code] = District.objects.get(code=district_code)
                    if constituency_code not in self.constituency_cache:
                        self.constituency_cache[constituency_code] = Constituency.objects.get(code=constituency_code)

                    state = self.state_cache[state_code]
                    district = self.district_cache[district_code]
                    constituency = self.constituency_cache[constituency_code]

                    # Check if already exists
                    if options['skip_existing']:
                        if PollingBooth.objects.filter(
                            constituency=constituency,
                            booth_number=booth_number
                        ).exists():
                            self.stats['booths']['skipped'] += 1
                            continue

                    if not options['dry_run']:
                        booth, created = PollingBooth.objects.update_or_create(
                            constituency=constituency,
                            booth_number=booth_number,
                            defaults={
                                'state': state,
                                'district': district,
                                'name': row.get('name', '').strip(),
                                'building_name': row.get('building_name', '').strip(),
                                'address': row.get('address', '').strip(),
                                'area': row.get('area', '').strip(),
                                'landmark': row.get('landmark', '').strip(),
                                'pincode': row.get('pincode', '').strip(),
                                'latitude': Decimal(row.get('latitude', 0) or 0) if row.get('latitude') else None,
                                'longitude': Decimal(row.get('longitude', 0) or 0) if row.get('longitude') else None,
                                'total_voters': int(row.get('total_voters', 0) or 0),
                                'male_voters': int(row.get('male_voters', 0) or 0),
                                'female_voters': int(row.get('female_voters', 0) or 0),
                                'other_voters': int(row.get('other_voters', 0) or 0),
                                'is_active': row.get('is_active', 'True').lower() in ['true', '1', 'yes'],
                                'is_accessible': row.get('is_accessible', 'True').lower() in ['true', '1', 'yes'],
                                'metadata': json.loads(row.get('metadata', '{}')) if row.get('metadata') else {},
                            }
                        )

                        if created:
                            self.stats['booths']['created'] += 1
                        else:
                            self.stats['booths']['updated'] += 1
                    else:
                        self.stats['booths']['created'] += 1

                    # Progress indicator
                    total_processed = sum(self.stats['booths'].values())
                    if total_processed % 500 == 0:
                        self.stdout.write(f"   ... processed {total_processed} booths", ending='\r')

                except Exception as e:
                    self.stats['booths']['errors'] += 1
                    if self.stats['booths']['errors'] <= 10:  # Only show first 10 errors
                        self.stdout.write(self.style.ERROR(
                            f"\n   Error importing booth {row.get('constituency_code')}/{row.get('booth_number')}: {e}"
                        ))

        self.stdout.write(f"\n   ‚úÖ Processed {sum(self.stats['booths'].values())} polling booths")

    def _print_summary(self, dry_run: bool = False):
        """Print import summary"""
        self.stdout.write("\n" + "="*70)
        self.stdout.write(self.style.SUCCESS("üìä IMPORT SUMMARY" + (" (DRY RUN)" if dry_run else "")))
        self.stdout.write("="*70)

        for category in ['states', 'districts', 'constituencies', 'booths']:
            stats = self.stats[category]
            total = sum(stats.values())
            self.stdout.write(f"\n{category.capitalize()}:")
            self.stdout.write(f"  Created:  {stats['created']:,}")
            self.stdout.write(f"  Updated:  {stats['updated']:,}")
            self.stdout.write(f"  Skipped:  {stats['skipped']:,}")
            if stats['errors'] > 0:
                self.stdout.write(self.style.ERROR(f"  Errors:   {stats['errors']:,}"))
            self.stdout.write(f"  Total:    {total:,}")

        self.stdout.write("="*70)
